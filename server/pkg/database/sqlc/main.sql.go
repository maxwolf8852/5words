// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: main.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCoins = `-- name: AddCoins :exec
UPDATE users SET coins=coins+$2 WHERE id=$1
`

type AddCoinsParams struct {
	ID    int64 `json:"id"`
	Coins int64 `json:"coins"`
}

func (q *Queries) AddCoins(ctx context.Context, arg AddCoinsParams) error {
	_, err := q.db.Exec(ctx, addCoins, arg.ID, arg.Coins)
	return err
}

const addWord = `-- name: AddWord :exec
INSERT INTO all_words (word) VALUES ($1) ON CONFLICT DO NOTHING
`

func (q *Queries) AddWord(ctx context.Context, word string) error {
	_, err := q.db.Exec(ctx, addWord, word)
	return err
}

const checkCompleted = `-- name: CheckCompleted :one
SELECT ((SELECT word from all_words aw WHERE aw.id=$2 LIMIT 1) IN (SELECT user_word FROM user_attempts WHERE user_id=$1 AND word_id=$2))
`

type CheckCompletedParams struct {
	UserID int64 `json:"user_id"`
	ID     int64 `json:"id"`
}

func (q *Queries) CheckCompleted(ctx context.Context, arg CheckCompletedParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, checkCompleted, arg.UserID, arg.ID)
	var exists interface{}
	err := row.Scan(&exists)
	return exists, err
}

const checkWord = `-- name: CheckWord :one
SELECT id FROM all_words WHERE word=$1
`

func (q *Queries) CheckWord(ctx context.Context, word string) (int64, error) {
	row := q.db.QueryRow(ctx, checkWord, word)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const completedAttempts = `-- name: CompletedAttempts :one
SELECT COUNT(*) AS attempt_count FROM user_attempts ua WHERE ua.user_id=$1 AND ua.word_id <> current_uncompleted($1) AND check_completed($1, ua.word_id)=TRUE
`

func (q *Queries) CompletedAttempts(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, completedAttempts, userID)
	var attempt_count int64
	err := row.Scan(&attempt_count)
	return attempt_count, err
}

const countAttempts = `-- name: CountAttempts :one
SELECT COUNT(*) AS atempt_count, COUNT(DISTINCT word_id) AS word_count FROM user_attempts WHERE user_id=$1 AND word_id <> current_uncompleted($1)
`

type CountAttemptsRow struct {
	AtemptCount int64 `json:"atempt_count"`
	WordCount   int64 `json:"word_count"`
}

func (q *Queries) CountAttempts(ctx context.Context, userID int64) (CountAttemptsRow, error) {
	row := q.db.QueryRow(ctx, countAttempts, userID)
	var i CountAttemptsRow
	err := row.Scan(&i.AtemptCount, &i.WordCount)
	return i, err
}

const countCompleted = `-- name: CountCompleted :one
SELECT COUNT(*) FROM user_attempts ua WHERE ua.user_id=$1 AND (SELECT word from all_words aw WHERE aw.id=ua.word_id LIMIT 1)=ua.user_word
`

func (q *Queries) CountCompleted(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countCompleted, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const currentWord = `-- name: CurrentWord :one
SELECT current_word()
`

func (q *Queries) CurrentWord(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, currentWord)
	var current_word int64
	err := row.Scan(&current_word)
	return current_word, err
}

const generateWord = `-- name: GenerateWord :exec
SELECT generate_word()
`

func (q *Queries) GenerateWord(ctx context.Context) error {
	_, err := q.db.Exec(ctx, generateWord)
	return err
}

const getWord = `-- name: GetWord :one
SELECT word FROM all_words WHERE id=$1
`

func (q *Queries) GetWord(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getWord, id)
	var word string
	err := row.Scan(&word)
	return word, err
}

const history = `-- name: History :many
SELECT ua.id, ua.word_id, ua.user_word, (SELECT word FROM all_words aw WHERE aw.id=w5.word_id LIMIT 1) AS real_word FROM words_5 w5 JOIN user_attempts ua ON w5.word_id = ua.word_id WHERE ua.user_id=$1 AND w5.word_id <> current_uncompleted($1)
`

type HistoryRow struct {
	ID       int32  `json:"id"`
	WordID   int64  `json:"word_id"`
	UserWord string `json:"user_word"`
	RealWord string `json:"real_word"`
}

func (q *Queries) History(ctx context.Context, userID int64) ([]HistoryRow, error) {
	rows, err := q.db.Query(ctx, history, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HistoryRow
	for rows.Next() {
		var i HistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.WordID,
			&i.UserWord,
			&i.RealWord,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const login = `-- name: Login :one
SELECT id
FROM users
WHERE username = $1
    AND password_hash = $2
`

type LoginParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (int64, error) {
	row := q.db.QueryRow(ctx, login, arg.Username, arg.PasswordHash)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const registerAttempt = `-- name: RegisterAttempt :one
INSERT INTO user_attempts (user_id, word_id, user_word) VALUES ($1, $2, $3) RETURNING id
`

type RegisterAttemptParams struct {
	UserID   int64  `json:"user_id"`
	WordID   int64  `json:"word_id"`
	UserWord string `json:"user_word"`
}

func (q *Queries) RegisterAttempt(ctx context.Context, arg RegisterAttemptParams) (int32, error) {
	row := q.db.QueryRow(ctx, registerAttempt, arg.UserID, arg.WordID, arg.UserWord)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const userAttempts = `-- name: UserAttempts :many
SELECT id,
    user_word
FROM user_attempts
WHERE user_id = $1 AND word_id =$2
`

type UserAttemptsParams struct {
	UserID int64 `json:"user_id"`
	WordID int64 `json:"word_id"`
}

type UserAttemptsRow struct {
	ID       int32  `json:"id"`
	UserWord string `json:"user_word"`
}

func (q *Queries) UserAttempts(ctx context.Context, arg UserAttemptsParams) ([]UserAttemptsRow, error) {
	rows, err := q.db.Query(ctx, userAttempts, arg.UserID, arg.WordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAttemptsRow
	for rows.Next() {
		var i UserAttemptsRow
		if err := rows.Scan(&i.ID, &i.UserWord); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userInfo = `-- name: UserInfo :one
SELECT id,
    username,
    created,
    coins
FROM users
WHERE id = $1
`

type UserInfoRow struct {
	ID       int64              `json:"id"`
	Username string             `json:"username"`
	Created  pgtype.Timestamptz `json:"created"`
	Coins    int64              `json:"coins"`
}

func (q *Queries) UserInfo(ctx context.Context, id int64) (UserInfoRow, error) {
	row := q.db.QueryRow(ctx, userInfo, id)
	var i UserInfoRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Created,
		&i.Coins,
	)
	return i, err
}

const users = `-- name: Users :many
SELECT id, username, interact, coins FROM users
`

type UsersRow struct {
	ID       int64              `json:"id"`
	Username string             `json:"username"`
	Interact pgtype.Timestamptz `json:"interact"`
	Coins    int64              `json:"coins"`
}

func (q *Queries) Users(ctx context.Context) ([]UsersRow, error) {
	rows, err := q.db.Query(ctx, users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersRow
	for rows.Next() {
		var i UsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Interact,
			&i.Coins,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wordFreq = `-- name: WordFreq :many
 SELECT user_word, COUNT(*) AS word_count FROM user_attempts WHERE user_id=$1 AND word_id <> current_uncompleted($1) GROUP BY user_word ORDER BY word_count DESC LIMIT $2
`

type WordFreqParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

type WordFreqRow struct {
	UserWord  string `json:"user_word"`
	WordCount int64  `json:"word_count"`
}

func (q *Queries) WordFreq(ctx context.Context, arg WordFreqParams) ([]WordFreqRow, error) {
	rows, err := q.db.Query(ctx, wordFreq, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordFreqRow
	for rows.Next() {
		var i WordFreqRow
		if err := rows.Scan(&i.UserWord, &i.WordCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wordId = `-- name: WordId :one
SELECT id FROM all_words WHERE word=$1
`

func (q *Queries) WordId(ctx context.Context, word string) (int64, error) {
	row := q.db.QueryRow(ctx, wordId, word)
	var id int64
	err := row.Scan(&id)
	return id, err
}
